\subsection{Portal Web}
La implementación del portal Web se realizó bajo la arquitectura orientada a servicios (ver Apéndice \ref{sec-soa}), lo cual implica una división del portal Web de la siguiente forma:
\begin{itemize}
	\item [Backend]: la parte del portal ofrece los servicios Web, con tiene los servicios de autenticación, administración de órdenes de reposición y generación de reportes.
	\item [Frontend]: la parte del portal que consume los servicios Web y muestra una interfaz gráfica al usuario, contiene las páginas de HTML y rutinas para consumir los servicios del Backend.
\end{itemize}

\subsubsection{Implementación del Backend}
La implementación del Backend está implementada utilizando el marco de trabajo Spring y sus bibliotecas:
\begin{itemize}
 	\item Spring boot: provee un ambiente de desarrollo y ejecución para aplicaciones basadas en el marco de trabajo Spring (ver sección \ref{sec-spring-boot}). 
 	\item Spring security: biblioteca para los servicios de autenticación y autorización de usuarios (ver sección \ref{sec-spring-security}).
\end{itemize}

\paragraph{Implementación de los servicios de seguridad\\}
Los servicios para autenticar y validar usuarios se implementaron siguiendo la especificación OAtuh 2.0 (ver sección \ref{sec-oauth}), el marco de trabajo Spring con sus bibliotecas Spring boot y Spring security.\\
La implementación de la seguridad utilizando Spring Security se divide en tres tareas:
\begin{enumerate}
	\item Habilitar filtros de seguridad, en el Código \ref{lst:enable-oauth} se muestra la configuración de necesaria:
	\begin{enumerate}
		\item Línea 2: habilita el uso de la especificación OAuth2.
		\item Línea 7: configuración principal de Spring security para no interponerse con los filtros de OAuth.
		\item Línea 12: creación del filtro de OAuth.
	\end{enumerate}
\begin{lstlisting}[language=Java, caption={Clase para habilitar los filtros de seguridad.}, captionpos=b, label={lst:enable-oauth}]
@Configuration
@EnableOAuth2Client
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter{

	@Override
	protected void configure(HttpSecurity http) throws Exception{
		http.antMatcher("/**").authorizeRequests().anyRequest().authenticated().and().logout().logoutSuccessUrl("/").permitAll().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().csrf().disable();
		http.authenticationProvider(authenticationProvider);
	}
	
	@Bean
	public FilterRegistrationBean oauth2ClientFilterRegistration(
			OAuth2ClientContextFilter filter){
		FilterRegistrationBean registration = new FilterRegistrationBean();
		registration.setFilter(filter);
		registration.setOrder(-100);
		return registration;
	}
}	
\end{lstlisting}

	\item Habilitar servicios de autorización: se refiere a dar un token de acceso (como lo especifica OAuth 2.0), en el código \ref{lst:enable-auth-server} se muestra la declaración de una clase para la configuración de un servidor de autorización:

\begin{lstlisting}[language=Java, caption={Clase de autenticación de usuarios.}, captionpos=b, label={lst:enable-auth-server}]
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter{
}
\end{lstlisting}

	En el Código \ref{lst:user-auth} se muestra la configuración necesaria para autenticar usuarios:
	\begin{enumerate}
		\item Línea 2: inyección del bean que realiza la autenticación de usuarios.
		\item Línea 4: creación del bean encargado de almacenar los tokens de los usuarios.
		\item Línea 10: configuración del punto de entrada para autenticación.
		\item Línea 11: se establece la referencia al bean que autentica usuarios.
		\item Línea 12: se establece la referencia al bean que administra los tokens de los usuarios.
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Configuración de autenticación de usuarios.}, captionpos=b, label={lst:user-auth}]
@Autowired
private AuthenticationManager authenticationManager;

@Bean
public TokenStore tokenStore(){
	TokenStore tokenStore = new InMemoryTokenStore();
	return tokenStore;
}

@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception{
	endpoints.authenticationManager(authenticationManager);
	endpoints.tokenStore(tokenStore());
}
\end{lstlisting}

	En el Código \ref{lst:client-auth} se muestra la configuración para la autenticación del cliente (Frontend):

	\begin{enumerate}
		\item Líneas 1 a 4: lectura de las credencia les del cliente.
		\item Línea 10: configuración del protocolo para la autenticación del cliente. 
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Clase de autenticación de cliente.}, captionpos=b, label={lst:client-auth}]
@Value("${oauth.server.client.id}")
private String clientId;
@Value("${oauth.server.client.secret}")
private String clientSecret;

@Autowired
private EncodedClientDetailsService ecds;

@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception{
	BaseClientDetails details = new BaseClientDetails();
	details.setClientId(clientId);
	details.setClientSecret(clientSecret);
	details.setAuthorizedGrantTypes(Arrays.asList("password"));
	ecds.addClientDetails(details);
	clients.withClientDetails(ecds);
}
\end{lstlisting}


	\item Habilitar acceso a recursos: estos recursos pueden ser los elementos estáticos que muestra el explorador de Internet, es decir, rutinas de javascript, páginas HTML, hojas de estilo e imágenes; o el consumo de servicios Web en el Código \ref{lst:enable-resource-server} se muestra la configuración del servidor de recursos:

	\begin{enumerate}
		\item Línea 2: habilitar el servidor de recursos.
		\item Línea 5: configuración del servidor de recursos.
		\item Línea 7: enunciación de las URLs públicas.
		\item Línea 8: enunciación de las URLs que requieren de un usuarios autorizado. 
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Clase de configuración de servidor de recursos.}, captionpos=b, label={lst:enable-resource-server}]
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter{
	@Override
	public void configure(HttpSecurity http) throws Exception{
		http.authorizeRequests()
			.antMatchers(PUBLIC_URLS).permitAll()
			.anyRequest().authenticated();
	}
}
\end{lstlisting}
\end{enumerate}

\paragraph{Implementación de los servicios Web de administración\\}
Los servicios web de administración fueron divididos en dos controles REST de Spring, 
\begin{enumerate}
	\item \textbf{DataController}: expone servicios referentes a la gestión de órdenes de reposición, en el Código \ref{lst:data-controller} se muestra la estructura principal de esta clase:
	\begin{enumerate}
		\item Línea 1: indicación para crear un un bean que expone servicios REST.
		\item Línea 3: inyección del bean de MyBatis para administrar órdenes de reposición.
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Controlador para exponer servicios Web de órdenes de reposición.}, captionpos=b, label={lst:data-controller}]
@RestController
public class DataController{
	@Autowired
	private IOrdernesDao ordenesDao;
}
\end{lstlisting}

	Dentro de la clase declara como un bean que exponen servicios web se declaran métodos que serán expuestos como un servicio web, en el Código \ref{lst:data-controller} se muestra el servicio web para obtener una orden de reposición:
	\begin{enumerate}
		\item Línea 1: la anotación \textbf{RequestMapping} indica como se debe asociar el método URLs por medio de sus parámetros:
		\begin{enumerate}
			\item value: URL con la cuál es asociada el método, el parámetro entre corchetes indica que es variable.
			\item method: método de HTTP al cuál es asociado el método. 
		\end{enumerate}
		\item Línea 3: la anotación \textbf{PathVariable} indica que el valor del parámetro es tomado de la URL, en este caso se refiere al número identificador de la orden de reposición buscada.
		\item Línea 5: obtención de la orden de reposición.
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Servicio Web para obtener una orden de reposición.}, captionpos=b, label={lst:data-controller}]
@RequestMapping(value = "/_data_/orden/{id}",
				method = RequestMethod.GET)
public OrdenImss getOrden(@PathVariable("id") Long id) throws SQLException{

	return ordenesDao.getOrdenById(id);

}
\end{lstlisting}

	\item \textbf{ReportController}: expone servicios referentes a la generación de reportes, en el Código \ref{lst:report-controller} se muestra la estructura principal de esta clase:
\begin{lstlisting}[language=Java, caption={Controlador para exponer servicios Web de generación de reportes.}, captionpos=b, label={lst:report-controller}]
@Controller
public class ReportController{
	@Autowired
	private IOrdenesDao ordenesDao;
	
	@Autowired
	private IReportService reportService;
}
\end{lstlisting}

	En el Código \ref{lst:report-controller-gen} se muestra el servicio web para la generación de reportes:
	\begin{enumerate}
		\item Línea 1: la anotación \textbf{RequestMapping} indica como se debe asociar el método URLs por medio de sus parámetros:
		\begin{enumerate}
			\item value: URL con la cuál es asociada el método.
			\item method: método de HTTP al cuál es asociado el método.
			\item produces: indica el formato de respuesta, en este caso es un flujo de datos.
		\end{enumerate}
		\item Líneas 12 y 13: traducción de las fechas que acotan el reporte a un objeto Date.
		\item Línea 15: delegación de la generación del reporte al servicio de generación de reportes.
		\item Línea 16: si el reporte no es vacío, entonces se manda el reporte como flujo de bytes.
		\item Línea 17: si el reporte es vacío se manda un mensaje de error.
	\end{enumerate}

\begin{lstlisting}[language=Java, caption={Servicio Web para generar un reporte.}, captionpos=b, label={lst:report-controller-gen}]
@RequestMapping(value = "/_report_/generate",
				method = RequestMethod.GET,
				produces = "application/octet-stream")
public void generateReport(HttpServletRequest request,
						   HttpServletResponse response,
						   @RequestParam("reporte") ReportType rType,
						   @RequestParam("fecIni") String fecIni,
						   @RequestParam("fecFin") String fecFin,
						   @RequestParam("horIni") String horIni,
						   @RequestParam("horFin") String horFin)
					throws IOException{
	Date low = parseDate(fecIni, horIni);
	Date high = parseDate(fecFin, horFin);
	
	String pathfile = reportService.generate(rType, low, high);
	if(pathfile !=null && !pathfile.isEmpty()){
		writeOut(pathfile, request, response);
	}else{
		Writer out = response.getWriter();
		out.append("No se han encontrado resultados");
		out.flush();
	}
}
\end{lstlisting}

\end{enumerate}


\subsubsection{Implementación del Fronend}
La implementación del Frontend está basada en el marco de trabajo AngularJS (ver sección \ref{sec-angular}), en el Código \ref{lst:portal-js} como se muestra la implementación de la aplicación con AngularJS:
\begin{enumerate}
	\item Línea 1: creación del módulo de AngularJS.
	\item Líneas 2 a 19: configuración de las vistas y rutas.
\end{enumerate}
\begin{lstlisting}[language=Javascript, caption={Módulo de AngularJS para el portalWeb}, captionpos=b, label={lst:portal-js}]
var app = angular.module('portalApp', ['ngRoute', 'ui.bootstrap']);
portal.config(function($routeProvider, $httpProvider){
	$routeProvider
		.when('/',
			{templateUrl : 'login.html', controller : 'loginCtrl'})
		.when('/login',
			{templateUrl : 'login.html', controller : 'loginCtrl'})
		.when('/layout',
			{templateUrl: 'layout.html', controller: 'layoutCtrl'})
		.when('/catalog',
			{templateUrl: 'catalogos.html', controller: 'catalogosCtrl'})
		.when('/search',
			{templateUrl: 'ordenesFind.html', controller: 'ordenesFinderCtrl'})
		.when('/ordenesList',
			{templateUrl: 'ordenesList.html', controller: 'ordenesListCtrl'})
		.when('/ordenesEdit/:ordenId',
			{templateUrl : 'ordenesEdit.html', controller : 'ordenesEditCtrl'})
		.otherwise({redirectTo : '/'});
});
\end{lstlisting}

El Frontend cuenta con las siguientes vistas:

\paragraph{1. Vista Acceso\\}
Los flujos de autenticación y autorización del sistema AutoSA se hacen siguiendo la especificación de OAuth (ver sección \ref{sec-oauth}). La autenticación se muestra al usuario mediante la plantilla del Código \ref{lst:longin-view} donde se ligan el nombre de usuario y la contraseña con el modelo de angular.

\begin{lstlisting}[language=HTML, caption={Plantilla HTML de acceso.}, captionpos=b, label={lst:longin-view}]
<form role="form" ng-submit="login()">
	<div class="form-group">
		<label for="username">Username:</label>
		<input type="text" class="form-control" id="username" name="username" ng-model="credentials.username"/>
	</div>
	<div class="form-group">
		<label for="password">Password:</label>
		<input type="password" class="form-control" id="password" name="password" ng-model="credentials.password"/>
	</div>
	<button type="submit" class="btn btn-primary">Submit</button>
</form>
\end{lstlisting}


Como se aprecia en la Figura \ref{lst:longin-view} se liga función \consolatext{login} al evento de envío de la forma, la implementación de la función se muestra en el Código \ref{lst:login-ctrl-js}:
\begin{enumerate}
	\item Línea 1, llamada a la función \consolatext{login} del servicio de autenticación, \consolatext{LoginService},
	\item Líneas 2 y 3, en caso de que la llamada sea exitosa se agrega el token de acceso a los encabezados de las llamadas a servicios Web, con este paso no es necesario hacer de manera explícita la autorización a recursos.
\end{enumerate}

\begin{lstlisting}[language=Javascript, caption={Uso del servicio que optine un token de acceso.}, captionpos=b, label={lst:login-ctrl-js}]
LoginService.login($scope.credentials)
	.success(function(data){
		$http.defaults.headers.common.Authorization = 'Bearer ' + data.access_token;
		$rootScope.authenticated = true;
		$location.path('/layout').replace();
		$scope.error = false;
})
\end{lstlisting}

El servicio \consolatext{LoginService} es el encargado de efectuar la llamada al servicio Web de token de acceso, el Código \ref{lst:login-service-js} se muestra la implementación de tal servicio:
\begin{enumerate}
	\item Línea 1: declaración del servicio \consolatext{LoginService}.
	\item Línea 2: declaración de la función \consolatext{login}, esta función es la encargada de llamar al servicio Web para obtener un token de acceso.
	\item Línea 3: mapa de configuración para la llamada al servicio Web de token de acceso, se muestran únicamente las propiedades más relevantes.
	\item Línea 4: URL del servicio Web.
	\item Línea 7: encabezado con las credenciales del cliente de OAuth.
	\item Línea 10: nombre de usuario.
	\item Línea 11: contraseña codificada del usuario.
	\item Línea 12: identificador del cliente de OAuth.
	\item Línea 13: tipo de flujo de OAuth.
	\item Línea 16: llamada al servicio Web de token de acceso.
\end{enumerate}
\begin{lstlisting}[language=Javascript, caption={Servicio en AngularJS para obtener un token de acceso.}, captionpos=b, label={lst:login-service-js}]
portalSrvc.service('LoginService', function($http, $q){
	this.login = function(credentials){
		var settings = {
			"url": "http://localhost:8080/oauth/token",
			"method": "POST",
			"headers": {
				"Authorization": "Basic YWNtZTphY21lc2VjcmV0",
			},
			"params": {
				"username": credentials.username,
				"password": btoa(credentials.password),
				"client_id": "acme",
				"grant_type": "password"
			}
		};
		return $http(settings);
	};
});
\end{lstlisting}

\paragraph{2. Vista Reportes\\}

Servicio de angular para consumir el servicio Web que ofrece la generación de reportes.

Código \ref{lst:report-service-js}
\begin{enumerate}
	\item Línea 1: declaración del servicio de reportes.
	\item Línea 2: declaración de la función que llama al servicio Web.
	\item Línea 3: construcción de los parámetros para la URL del servicio Web.
	\item Línea 4: consulta del servicio Web en una nueva página del explorador de Internet.
\end{enumerate}
\begin{lstlisting}[language=Javascript, caption={Servicio en AngularJS para pedir la generación de un reporte.}, captionpos=b, label={lst:report-service-js}]
app.service('ReportService', function($http, $q, $window){
	this.buildReport = function(filtro){
		var params = 'fecIni=' + encodeURIComponent(filtro.fecIni.toJSON()) + "&" + 'fecFin=' + encodeURIComponent(filtro.fecFin.toJSON()) + "&" + 'horIni=' + encodeURIComponent(filtro.horIni.toJSON()) + "&" + 'horFin=' + encodeURIComponent(filtro.horFin.toJSON()) + "&" + 'reporte=' + encodeURIComponent(filtro.reporte.key);
		$window.open("_report_/generate?" + params);
	};
});
\end{lstlisting}


Controlador para la vista de generación de reportes. 
Código \ref{lst:report-ctrl-js}
\begin{enumerate}
	\item Línea 1: declaración del controlador
	\item Línea 2: definición de los valores iniciales del modelo.
	\item Línea 9: función que consume el servicio de generación de reportes.
\end{enumerate}
\begin{lstlisting}[language=Javascript, caption={Servicio en AngularJS para pedir la generación de un reporte.}, captionpos=b, label={lst:report-ctrl-js}]
app.controller('reportCtrl', function($scope, $window, $http, $timeout, ReportService){
	$scope.filtro = {
		fecIni: new Date(),
		horIni: new Date(0, 0, 0, 0, 0, 0, 0),
		fecFin: new Date(),
		horFin: new Date(0, 0, 0, 23, 59, 0, 0),
	};
	
	$scope.generate = function($event){
		ReportService.buildReport($scope.filtro);
	};
});
\end{lstlisting}

Declaración del formulario para la generación de reportes.
Código \ref{lst:view-report-form}
\begin{enumerate}
	\item Línea 1: uso de la directiva \consolatext{ng-form} para la generación.
	\item Línea 3: en este espacio se encuentran los campos del formulario.
	\item Líneas 4 y 5: botón para enviar el formulario.
	\begin{enumerate}
		\item La directiva \consolatext{ng-click} liga el evento de pulsar el botón con la función del controlador.
		\item La directiva \consolatext{ng-disabled} estable que el botón será habilitado cuando se cumpla la expresión que contiene, en este caso, que la forma tenga datos válidos.
	\end{enumerate}
\end{enumerate}
\begin{lstlisting}[language=HTML, captionpos=b, caption={}, label={lst:view-report-form}]
<ng-form name="reportForm">
	<h3>Generaci&oacute;n de <i>layout</i></h3>
	...
	<input type="submit" value="Generar" class="btn btn-primary"
			ng-click="generate($event)" ng-disabled="reportForm.$invalid"/>	
</ng-form>
\end{lstlisting}

Control para seleccionar el tipo de reporte.
Código \ref{lst:view-report-type-select}
\begin{enumerate}
	\item \consolatext{ng-model} liga al valor de la lista con el modelo.
	\item \consolatext{ng-options} genera las opciones de la lista.
	\item \consolatext{ng-required} indica que es necesario seleccionar un elemento de la lista.
\end{enumerate}
\begin{lstlisting}[language=HTML, captionpos=b, caption={}, label={lst:view-report-type-select}]
<select ng-model="filtro.reporte" name="reporte"
		ng-options="item.name for item in reportTypes"
		ng-required="true"
		class="form-control"></select>
\end{lstlisting}

Control para seleccionar fecha y hora de inicio (la selección para la fecha y hora de término es idéntico salvo que cambia la referencia al modelo).
Código \ref{lst:view-report-datetime}
\begin{enumerate}
	\item Línea 1: la directiva \consolatext{datepicker-popup} prepara el elemento para manejar el formato de fecha.
	\item Línea 7: la directiva \consolatext{timepicker} agrega el comportamiento para seleccionar la hora del día.
\end{enumerate}
\begin{lstlisting}[language=HTML, captionpos=b, caption={}, label={lst:view-report-datetime}]
<input class="form-control" type="text" datepicker-popup="dd/MM/yyyy" ng-model="filtro.fecIni" is-open="startDateOpen" ng-required="true" starting-day="1" />

<button type="button" class="btn btn-default" ng-click="openStartDate($event)">
	<i class="glyphicon glyphicon-calendar"></i>
</button>

<timepicker ng-model="filtro.horIni" minute-step="30" ng-class="form-control"></timepicker>
\end{lstlisting}

\paragraph{3. Vista Catálogos\\}

\paragraph{4. Vista Búsqueda\\}

\paragraph{5. Vista Orden\\}
En esta vista se ofrece al usuario la visualización de una orden de reposición, la modificación de los datos de la misma y la generación del acuse de envío.

