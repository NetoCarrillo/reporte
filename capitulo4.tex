\chapter{Implementación}\label{cap4}

\section{Tecnologías utilizadas}
%-------------------------------------------------------------------------------
\subsection{Base de datos relacional}\label{sec:bd-r}
Una base de datos relaciones es una colección de tablas relacionadas entre sí. La colección de tablas se describe a sí misma en cuanto a que el significado de los datos contenidos pertenecen a un mismo ámbito\cite{DataBaseConcepts}.\\
Una base de datos es administrada mediante un Sistema Administrador de Bases de Datos (en inglés Database Management System, DBMS), un DBMS es un programa de computadora usado para crear, procesar y administrar bases de datos. El DBMS recibe peticiones en el lenguaje de programación SQL (como se describe más adelante) y traduce esas peticiones a acciones dentro de la base de datos\cite{DataBaseConcepts}.\\
Las siguientes son definiciones de los conceptos más relevantes dentro de esta área de conocimiento:
\begin{enumerate}
	\item \textbf{Tabla}: es un conjunto de renglones (registros) y columnas (atributos) que cumplen con las siguientes características\cite{DataBaseConcepts}:
	\begin{enumerate}
		\item Los renglones contienen únicamente datos relacionados con la tabla.
		\item Las entradas de una columna contienen un solo valor.
		\item Todas las entradas de una columna son del mismo tipo.
		\item Las columnas tienen un nombre único dentro de la tabla.
		\item El orden de las columnas y los renglones no es relevante.
		\item No contiene dos renglones idénticos.
	\end{enumerate}
	\item \textbf{Vista}: es una tabla derivada de una consulta de otras tablas, éstas tablas pueden ser tablas de la base de datos o vistas definidas previamente. Una vista es considerada como tabla virtual ya que no necesariamente existe físicamente, a diferencia de una tabla de la base cuyas tuplas siempre están almacenadas físicamente en la base de datos\cite{FundamentalsOfDBSystems}.
	\item \textbf{Llave primaria}: es el conjunto de columnas que identifican de manera unívoca a cada renglón de la tabla.\cite{DataBaseConcepts}
	\item \textbf{Llave foránea}: define la relación de una tabla \textbf{A}, hacia otra tabla \textbf{B}, la relación satisface las siguientes condiciones\cite{FundamentalsOfDBSystems, DataBaseConcepts}:
	\begin{enumerate}
		\item Los atributos de las tablas \textbf{A} y \textbf{B} son del mismo tipo y se tiene una correspondencia uno a uno.
		\item Los atributos en la tabla \textbf{B} son exactamente los mismos de la llave primaria de la tabla \textbf{B}.
	\end{enumerate}
	\item \textbf{Restricción de integridad}: son reglas que se utilizan para asegurar que cambios en los datos de las tablas no causen inconsistencia en la información\cite{DatabaseSystemConcepts}. En particular el conocido como \texttt{NOT NULL} indica que el valor del atributo no puede ser nulo\cite{FundamentosSistemasBasesDatos}.
	\item \textbf{Índice}: es una estructura auxiliar para agilizar la obtención de registros. Los índices proveen rutas de acceso alternativo a los registros de la base de datos sin afectar la colocación física de éstos\cite{FundamentalsOfDBSystems}.
	\item \textbf{Lenguaje Estructurado de Consultas}, traducción del inglés Structured Query Language (SQL): fue desarrollado por IBM\textsuperscript{\textcopyright} al final de los años setenta. Es un lenguaje de datos orientado a texto, el cual ha sido avalado por el Instituto Nacional de Estándares Americanos (ANSI por sus siglas en inglés) dando así los estándares ANSI para SQL, principalmente para este trabajo el estándar ANSI-92 o SQL-92.
	\item \textbf{Lenguaje de Definición de Datos}, traducción del inglés Data Definition Language (DDL): son sentencias de SQL cuya función es describir la creación de estructuras tales como tablas, índices y restricciones, entre otras\cite{DataBaseConcepts}.
	\item \textbf{Lenguaje de Modelado de Datos}, traducido del inglés Data Modeling Language (DML): son las sentencias SQL cuya función es describir la modificación de datos, es decir, sentencias de inserción, borrado y actualización de datos\cite{DataBaseConcepts}.  
\end{enumerate}

%-------------------------------------------------------------------------------
\subsection{OAuth 2.0}\label{sec:oauth}
Bihis describe de la siguiente manera a OAuth 2.0:
\begin{quote}
	OAuth 2.0 es un protocolo que permite compartir información y recursos a distintas aplicaciones de manera segura y confiable\cite{MasteringOAuth2}.
\end{quote}
Spasovski complementa la descripción diciendo que OAuth 2.0 provee autorización para que un cliente pueda a su vez autorizar peticiones a recursos protegidos de un servicio a nombre del dueño (usuario de la aplicación o sistema)\cite{OAuth2Identity}.
Se especifican cuatro roles que intervienen en el flujo del protocolo de autorización y acceso a recursos protegidos\cite{OAuthRFC}:
\begin{enumerate}
	\item Dueño del recurso: una entidad que es capaz de otorgar acceso a recursos protegidos, cuando el dueño del recurso es una persona se conoce como usuario final.
	\item Servidor de recursos: el servidor que contiene los recursos protegidos, es capaz de aceptar y responder a peticiones de recursos protegidos utilizando un lexema (\textit{token}\footnote{A lo largo de este trabajo se hará referencia al lexema por su nombre en inglés \textit{token} ya se acopla mejor al contexto.}) de acceso.
	\item Cliente: es una aplicación que hace peticiones a recursos protegidos por medio de su nombre y de autorización del dueño del recurso.
	\item Servidor de autorizaciones: es el servidor que genera lexemas (\textit{tokens}) de acceso a los clientes después de autentificar exitosamente al dueño del recurso y haber obtenido autorización.
\end{enumerate}
La interacción entre el servidor de autorizaciones y el servidor de recursos se encuentra fuera del alcance de la especificación de OAtuh 2.0. El servidor de autorizaciones podría ser el mismo que el servidor de recursos o ser entidades separadas. Un servidor de autorizaciones puede generar \textit{tokens} de acceso para múltiples servidores de recursos\cite{OAuthRFC}.\\
La definición de los roles utiliza el concepto de \textit{token} de acceso el cuál está definido en el estándar de la siguiente forma\cite{OAuthRFC}:
\begin{quote}
	\textit{Token} de acceso\footnote{De ahora en adelante referido únicamente como \textit{token}.} es una cadena que representa la autorización hecha al cliente. Usualmente la cadena no tiene un significado claro para el cliente. Los \textit{tokens} representan alcance y duración específicos otorgados por el dueño del recurso y respaldados por el servidor de recursos y el servidor de autorizaciones.
\end{quote}

OAuth define varios escenarios del flujo de autorización, para fines del proyecto AutoSA únicamente se hará mención del flujo de autorización con identificador de usuario y contraseña\cite{OAuthRFC, OAuth2Identity}. El diagrama del flujo se muestra en la Figura \ref{fig:dia-seq-oauth-flow} y en este se puede observar que:
\begin{enumerate}
	\item El cliente envía tanto sus credenciales y como las credenciales de dueño del recurso (en este caso credenciales se refiere a un identificador y contraseña).
	\item El servidor de autorizaciones valida las credenciales del cliente.
	\item El servidor de autorizaciones valida las credenciales del dueño del recurso.
	\item El servidor de autorizaciones pide la generación de un \textit{token}.
	\item El servidor de autorizaciones entrega el \textit{token} al cliente.
	\item El cliente hace la petición de un recurso (acompañado del \textit{token}) al servidor de recursos.
	\item El servidor de recursos valida el \textit{token} de la petición. 
	\item El servidor de recursos valida entrega el recurso al cliente.
\end{enumerate}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dia-seq-oauth-flow}
	\caption{Diagrama de flujo de OAuth 2.0.}
	\label{fig:dia-seq-oauth-flow}
\end{figure}

\subsection{Derivación de clave}\label{sec:key-derivation}

Una \textbf{función hash} H acepta una cadena de longitud no acotada $M$ y produce una cadena de tamaño fijo $h=H(M)$. Una buena función hash tiene la propiedad que el resultado de aplicar a un conjunto grande de cadenas produce un conjunto de cadenas con distribución uniforme y aparentemente aleatorias\cite{CryptographyNetworkSecurity}.\\
El tipo de funciones hash ocupadas en seguridad son referidas como \textbf{funciones hash criptográficas}. Una función hash, $H$, se considera criptográfica si computacionalmente es infactible refutar las siguientes propiedades\cite{CryptographyNetworkSecurity}:
\begin{itemize}
	\item \textbf{Libre de colisiones}: para cualquier cadena $m$ no existe una cadena $n$ tal que si $m \neq n \Rightarrow H(m) = H(n)$. Es decir, la función hash no utiliza el mismo código para dos cadenas diferentes.
	\item \textbf{Un solo sentido}: para toda $s$ en la imagen de $H$, $\forall s \in H(M)$, no es posible encontrar $n$ tal que $f(n) = s$. Esta propiedad significa que no es posible encontrar la cadena $n$ de la cual proviene el código hash $s$.
\end{itemize}

Un función de derivación de claves, o KDF por sus siglas en inglés, tiene como función elaborar una cadena de un tamaño predeterminado a partir de una cadena de tamaño variable.
Una función KDF tiene los siguientes parámetros\cite{UnderstandingCryptography, CryptographyTheoryPractice}:
\begin{itemize}
	\item contraseña: es una palabra secreta
	\item cadena aleatoria: es una palabra pública generada en forma aleatoria.
	\item número iteraciones: número de iteraciones que hará la función KDF.
\end{itemize}
La función de derivación concatena la contraseña y la cadena aleatoria, entonces aplica una función hash criptográfica por el número de iteraciones indicada, al resultado de esta función se le conoce como clave derivada\cite{UnderstandingCryptography, CryptographyTheoryPractice}.

%-------------------------------------------------------------------------------
\subsection{Java}\label{sec:java}

El lenguaje de programación Java fue creado en 1991 por James Gosling, Patrick Naughton, Chris Warth, Ed Frank y Mike Sheridan bajo el nombre ``Oak'' y en 1995 se cambió el nombre a Java. El lenguaje Java está basado en los lenguajes de programación C y C++. Java es un lenguaje Orientado a Objetos, estáticamente tipado y multiplataforma\cite{JavaCompleteReference, WellGroundedJavaDeveloper}.\\
Java cuenta con varios componentes, de los cuales únicamente se describirán los más relevantes para el proyecto AutoSA\cite{JavaCompleteReference, WellGroundedJavaDeveloper}:
\begin{enumerate}
	\item \textbf{Máquina Virtual de Java}, traducido del inglés Java Virtual Machine (JVM): es el sistema en tiempo de ejecución de Java.
	\item \textbf{Bytecode}: es el nombre que recibe el conjunto optimizado de instrucciones diseñadas para ser ejecutadas en la JVM.
	\item \textbf{Paquete de Desarrollo de Java}, traducido del inglés Java Development Kit (JDK): es el conjunto de herramientas utilizadas para el desarrollo de software para la Máquina Virtual de Java.
	\item \textbf{Ambiente de Ejecución de Java} traducido del inglés Java Runtime Environment (JRE): es la herramienta encargada de la creación y administración de instancias de la Máquina Virtual de Java.
\end{enumerate}

\subsubsection{Java Data Base Controller}\label{sec:jdbc}
El controlador de base de datos de Java (del inglés Java Database Controller, JDBC) es un conjunto de APIs\footnote{API viene del inglés ``Application Programming Interface'' es utilizado para denotar los métodos que proporciona una biblioteca.} que simplifica la conexión a bases de datos relacionales. Cabe mencionar que por medio del API JDBC también se puede tener acceso a otras fuentes de datos como los son hojas cálculo, archivos de texto plano o bases de datos no relacionales\cite{JDBCRecipes, BeginingJava8APIs}.

%-------------------------------------------------------------------------------
\subsection{Spring}\label{sec:spring}
\begin{quote}
	El maco de trabajo Spring provee un modelo comprensivo de programación y configuración para aplicaciones empresariales basadas en Java en cualquier tipo de plataforma de despliegue\cite{SpringFramework}.
\end{quote}

Las funciones principales de Spring, mejor conocido como Spring Core\cite{Spring5DesignPatterns, ProSpring5, WellGroundedJavaDeveloper, SpringInAction}:
\begin{enumerate}
	\item Inversión de control: es una técnica que externaliza y administra las dependencias entre componentes.

	\item Inyección de dependencia: es una forma particular de inversión de control, se refiere a establecer las dependencias de un objeto en tiempo de ejecución.

	\item Programación Orientada a Eventos: es una técnica que promueve la separación de funciones en un sistema de software. Un sistema de software se conforma de varios componentes. Cada uno es responsable de un conjunto de funcionalidades afines, a menudo estos componentes cargan con responsabilidades adicionales detrás de su función principal (escritura de bitácora, manejo de transacciones, funciones de autorización, etcétera), a estos servicios del sistema se les llama intersectoriales. El objetivo de la programación Orientada a Aspectos en Spring  es ofrecer una forma de manejar estas funciones intersectoriales sin mezclarlas con el código de las funciones principales, para lo cual utiliza los patrones de diseño \textit{Decorador} y \textit{Proxy} (ver secciones \ref{sec:decorator} y \ref{sec:proxy}, respectivamente).
\end{enumerate}

Dentro del proyecto de Spring existen proyectos que se enfocan en áreas específicas. A continuación se mencionan los proyectos que fueron utilizados para el proyecto AutoSA.

\subsubsection{Spring boot}\label{sec:spring-boot}
Es un proyecto de Spring que ofrece un ambiente de desarrollo y despliegue para aplicaciones desarrolladas con Spring y ofrece las siguientes características\cite{SpringBootInAction}:
\begin{enumerate}
	\item Iniciadores: agregar grupos comunes de dependencias. Cabe mencionar que en una sola de éstas puede ser agregada al administrador de proyectos.
	\item Auto-configuración: alivia la carga de configuración estableciendo valores por defecto, soportando configuración condicional.
	\item Solenoide: agrega características de administración a las aplicaciones.
\end{enumerate}

\subsubsection{Spring security}\label{sec:spring-security}
\begin{quote}
	La Seguridad de Spring (\textit{Spring Security}) es un marco de trabajo poderoso y altamente adaptable para procesos de autentificación y control de acceso. Es el estándar de seguridad para aplicaciones basadas en Spring. Enfocado en proveer a aplicaciones de Java funciones de autentificación y autorización\cite{SpringSecurity}.
\end{quote}

\begin{quote}
	El modelo de interceptación de seguridad de \textit{Spring security} se puede aplicar a dos áreas principales en una aplicación: URL y llamados a métodos. \textit{Spring security} engloba estos dos puntos de entrada de la aplicación, permitiendo el acceso cuando las restricciones de seguridad son cumplidas. Tanto la llamada a métodos como la cadena de filtros de seguridad dependen de la instancia de \texttt{SecurityInterceptor} donde la lógica principal reside en tomar la decisión de conceder o no el acceso\cite{ProSpringSecurity}.
\end{quote}
En al Figura \ref{fig:dia-spring-security} se muestra un diagrama del manejo que \textit{Spring security} brinda a las peticiones al sistema.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dia-spring-security}
	\caption{Diagrama de manejo de peticiones de Spring security\cite{ProSpringSecurity}.}
	\label{fig:dia-spring-security}
\end{figure}

%-------------------------------------------------------------------------------
\subsection{MyBatis}\label{sec:mybatis}
\begin{quote}
MyBatis es un marco de trabajo para manejar la persistencia con soporte para sentencias SQL personalizadas, procedimientos almacenados y conversión avanzada de datos. MyBatis elimina casi todo el código de JDBC, la configuración manual de parámetros y la recuperación de resultados\cite{MyBatis}.
\end{quote}

Los beneficios de MyBatis sobre otros marcos de trabajo para persistencia son\cite{PersistenceWithMyBatis}:
\begin{quote}
	\begin{itemize}
		\item Elimina gran parte del código repetitivo de JDBC.
		\item Tiene una curva de aprendizaje pequeña (es fácil de aprender).
		\item Trabaja bien con bases de datos antiguas.
		\item Encrustación de sentencias SQL.
		\item Provee integración con el marco de trabajo \textit{Spring}.
		\item Provee integración con bibliotecas para caché.
		\item Induce mejoras en el rendimiento.
	\end{itemize}
\end{quote}

El uso de MyBatis se resume principalmente a puntos\cite{PersistenceWithMyBatis}:
\begin{enumerate}
	\item Crear un archivo de configuración que contiene las sentencias SQL y conversiones de resultados a objetos de Java.
	\item Crear una interfaz de Java cuyos métodos correspondan a las sentencias SQL del archivo de configuración.
	\item Crear un objeto \texttt{SqlSession} del cual se obtiene una instancia de la interfaz. Por medio de tal instancia se realizan las operaciones a la base de datos.
\end{enumerate}

%-------------------------------------------------------------------------------
\subsection{Velocity}\label{sec:velocity}
\begin{quote}
	Velocity es un lenguaje de plantillas diseñado para dar a los diseñadores Web una forma fácil de presentar información dinámica a los usuarios de un sitio Web o aplicación. Para soportar el lenguaje se utiliza una colección de clases de Java como puente entre el modelo y la vista\cite{MasteringApacheVelocity} (ver Apéndice \ref{sec:mvc}).
\end{quote}

%-------------------------------------------------------------------------------
\subsection{Flying Saucer}\label{sec:flying-saucer}
\begin{quote}
	Flying Saucer es una biblioteca escrita en Java para traducir documentos XML o XHTML con CSS\footnote{Hoja de estilos en cascada, traducido del inglés\textit{Cascading Style Sheets}.} a formatos de gráficos de Java, PDF e imágenes\cite{FlyingSaucer}.
\end{quote}

%-------------------------------------------------------------------------------
\subsection{Javascript}\label{sec:javascript}
Javascript es un lenguaje de programación de rutinas, en un principio fue diseñado para utilizarse en exploradores de Internet, se le ha dado otro tipo de aplicaciones como es el desarrollo de aplicaciones de escritorio y servidores de aplicaciones. Un programa desarrollado con Javascript no depende de un compilador ya que un intérprete de Javascript ejecuta el código tal y como está escrito\cite{LearningWebDesign}.

%-------------------------------------------------------------------------------
\subsection{AngularJS}\label{sec:angularjs}

\begin{quote}
	AngularJS es un marco de trabajo escrito en Javascript para desarrollar aplicaciones Web, mantenida por Google\textsuperscript{\textcopyright}\footnote{\textcolor{red}{Karla, no se si Google se debe escribir con el símbolo de copyright \textcopyright o trademark \texttrademark ¿Sabes como se decide eso?}}. Es un marco de trabajo de código abierto, el cual se enfoca en los retos de aplicaciones de una página. Una aplicación Web basada en AgularJS sigue el patrón de diseño MVC, facilitando las tareas de extensión, mantenimiento, ejecución de pruebas y seguimiento de estándares\cite{FullStackAngularJS}.
\end{quote}

\subsubsection{Componente básicos de AngularJS}
Al seguir el patrón MVC, AngularJS permite dividir la aplicación en componentes. A continuación se enlistan los componentes más importantes utilizados para el desarrollo del proyecto AutoSA\cite{FullStackAngularJS, LearningAngularJS, AngularJSEssentials}:
\begin{enumerate}
	\item Módulo \textit{(module)}: es el contenedor para los demás componentes de AngularJS. Cada módulo tiene su propia estructura de directorios para cada tipo de componente de AngularJS, y cada página en AngularJS tiene un módulo.
	\item Alcance \textit{(scope)}: es una representación en Javascript de datos usados para llenar una vista en una página Web. Los datos puede de cualquier fuente como una base de datos o un servicio Web.
	\item Vista \textit{(view)}: es la composición de plantillas (HTML) y directivas, las vistas son construidas dinámicamente en tiempo de ejecución al mezclar las plantillas con los datos del alcance, el resultado es código HTML puro.
	\item Plantilla \textit{(template)}: son fragmentos de código HTML con directivas y expresiones.
	\item Directiva \textit{(directive)}: es una extensión al vocabulario de HTML que permite definir nuevos comportamientos, entonces permite desarrollar componentes reutilizables.
	\item Expresión \textit{(expression)}: las expresiones se utilizan para ligar datos del alcance dentro de una plantilla HTML.
	\item Controlador \textit{(controller)}: es el control de patrón de diseño MVC, contiene la lógica de negocio y su función principal es exponer los datos a la vista utilizando el alcance.
	\item Ligado de datos \textit{(data binding)}: es el proceso de ligar datos del modelo a la vista en ambos sentidos, es decir, un cambio originado en una parte implica el cambio en la otra parte.
	\item Modelo \textit{(model)}: es el modelo del patrón de diseño MVC, es decir, son los datos.
	\item Servicio \textit{(service)}: son objetos que siguen el \textit{Patrón de Diseño Singleton} y proveen funcionalidad específica a la aplicación Web.
	\item Inyección de dependencias \textit{(dependency injection)}: es el proceso de inyectar dependencias en tiempo de ejecución, es utilizado para consumir los servicios.
\end{enumerate}

%-------------------------------------------------------------------------------
\subsection{Sahi}\label{sec:sahi}
\begin{quote}
	Sahi es una herramienta enfocada a la automatización de pruebas para servicios Web, plataformas Web, móviles, escritorio de Windows\textsuperscript{\textcopyright} y ambientes de desarrollo Java\cite{SahiPro}.
\end{quote}

Sahi incluye un modo de operación que permite ejecutar rutinas automatizadas sobre exploradores de Internet, la forma en Sahi logra la ejecución de rutinas es actuando como proxy\footnote{Un \textit{proxy} es un intermediario entre el cliente (explorador) y el servidor (página Web)\cite{BeginningUbuntuLinux}} entre el sitio Web y el explorador de Internet como se muestra en la Figura \ref{fig:dia-sahi-arq}. Cada vez que el explorador hace una petición al sitio Web, Sahi intercepta la comunicación e inserta código de Javascript que ejecuta la rutina automatizada\cite{WebEng9IntConf, SahiPro}.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{dia-sahi-arq}
\caption{Diagrama de flujo de Sahi\cite{SahiPro}.}
\label{fig:dia-sahi-arq}
\end{figure}

%================================================================================
%
%================================================================================

\section{Implementación de base de datos}\label{sec:impl-db}
El sistema AutoSA utiliza una base de datos relacional\footnote{Por confidencialidad no se hace mención específica del nombre y versión del sistema administrador de bases de datos.} para almacenar la información requerida en los casos de uso.\\
La implementación de la base de datos se ve reflejada en las rutinas con sentencias SQL donde se definen los objetos de la base de datos, tales rutinas se separan en dos grupos, las rutinas DDL y las rutinas DML.

%-------------------------------------------------------------------------------
\subsection{Rutinas de definición de datos}
Estas rutinas contienen las sentencias DDL para la creación de tablas, llaves primarias y foráneas, índices y restricciones. En el Código \ref{lst:sql-create-table} se muestra un ejemplo de la creación de la tabla \textit{ordenes\_is}.
\begin{lstlisting}[language=SQL, caption={Sentencia para crear una tabla.}, captionpos=b, label={lst:sql-create-table}]
CREATE TABLE ordenes_is(
   id numeric(20,0) PRIMARY KEY NOT NULL,
   orden numeric(20,0) NOT NULL,
   estatus numeric(2,0) NOT NULL,
   id_sesion_insersion numeric(20,0) NOT NULL,
   id_sesion_estatus numeric(20,0) NOT NULL,
   estatus_sa numeric(2,0),
   estatus_sap numeric(2,0)
);
\end{lstlisting}

La generación de reportes que se menciona en el caso de uso \textbf{Generar reporte} (ver sección \ref{cu-generar-reporte}), utiliza una vista para la definición de la consulta de los datos del reporte como se muestra en el Código \ref{lst:sql-create-view}, además se han implementado índices para agilizar tales consultas como se puede ver en el Código \ref{lst:sql-create-index}.

\begin{lstlisting}[language=SQL, caption={Sentencia para crear una vista.}, captionpos=b, label={lst:sql-create-view}]
CREATE VIEW ordenes_contestadas AS
     SELECT *
       FROM ordenes_is
      WHERE id_sesion_estatus = :sesion
        AND estatus = 3
\end{lstlisting}

\begin{lstlisting}[language=SQL, caption={Sentencia para crear un índice.}, captionpos=b, label={lst:sql-create-index}]
CREATE INDEX ordenes_contetadas_idx ON ordenes_is(id_sesion_estatus, estatus);
\end{lstlisting}

%-------------------------------------------------------------------------------
\subsection{Rutinas de modelado de datos}
Estas rutinas contienen la sentencias DML para insertar la información necesaria durante la ejecución del sistema, como son los estados posibles de las órdenes de reposición (ver Figura \ref{fig:dia-estados-orden}), en el Código \ref{lst:sql-insert} se muestra un ejemplo de la sentencia DML para insertar un registro.

\begin{lstlisting}[language=SQL, caption={Sentencia insertar un registro.}, captionpos=b, label={lst:sql-insert}]
INSERT INTO cat_estatus_orden (id,nombre) VALUES (1,'NUEVA');
\end{lstlisting}

%================================================================================
%
%================================================================================

\section{Implementación de los componentes}
\input{capitulo4-2-1-agent}
\input{capitulo4-2-2-logic}
\input{capitulo4-2-3-persistence}
\input{capitulo4-2-4-files}
\input{capitulo4-2-5-reporter}
\input{capitulo4-2-6-web}

%================================================================================
%
%================================================================================

\input{capitulo4-3-cumplimiento}

%================================================================================
%
%================================================================================

\section{Resumen}
La implementación del sistema AutoSA utiliza el lenguaje de programación Java para todas las bibliotecas que son ejecutadas en el servidor, el lenguaje SQL para realizar consultas a la base de datos y Javascript para las bibliotecas que son ejecutadas en el explorador de Internet del usuario.\\
La automatización con el Sistema de Abastecimiento se ha realizando utilizando la herramienta Sahi y algunas bibliotecas desarrolladas con el lenguaje de programación Java.\\
La implementación del Portal Web se ha hecho siguiendo la Arquitectura Orienta a Servicios, lo cual implica que por una parte se tiene un servidor que expone tales servicios a través de la Web, y por otro lado un cliente que los consume. Mientras que la implementación del cliente que consume los servicios Web se ha hecho utilizando el lenguaje Javascript y el marco de trabajo AngularJS, AngularJS sigue el patrón de diseño MVC. El manejo de autentificación y autorización de usuarios se ha hecho siguiendo la especificación OAuth 2.0.
